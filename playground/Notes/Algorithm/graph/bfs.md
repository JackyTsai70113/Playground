# BFS (Breadth-First Search)

## 什麼是 BFS？

**BFS**（Breadth-First Search）是一種圖遍歷演算法，用於遍歷或搜尋圖中的節點。BFS 從一個起始節點開始，先探索所有與該節點直接相連的節點，然後依次探索與這些節點相連的其他節點，直到遍歷完整個圖。

BFS 是一個逐層遍歷圖的算法，通常使用 **佇列（Queue）** 來輔助實現。

### BFS 適用情境：
- **最短路徑問題**：在無權重的圖中，BFS 可以用來找出從起點到其他所有節點的最短路徑。
- **圖的遍歷**：用來遍歷圖中的所有節點。
- **層次結構的問題**：適用於有層次結構的問題，如公司員工結構、網絡連接等。

## BFS 的基本步驟：
1. **初始化**：將起始節點加入佇列，並標記為已訪問。
2. **遍歷節點**：
   - 從佇列中取出一個節點，將它標記為已處理。
   - 將所有未被訪問過的鄰接節點加入佇列並標記為已訪問。
3. **結束條件**：當佇列空時，遍歷結束。

## BFS 代碼範例（C#）：

```csharp
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(List<int>[] graph, int root, int target) {
    if(root.val == target.val)
        return 0;
    Queue<Node> q = new();
    HashSet<Node> seen = new();
    q.Enqueue(root);
    seen.Add(root);
    int step = 0;
    while (q.Count > 0)
    {
        for(int i = q.Count; i > 0; --i)
        {
            var u = q.Dequeue();
            if(v.val == target.val)
                return step;
            foreach(var v in graph[u]) {
                if (!seen.Contains(v)) {
                    q.Enqueue(v);
                    seen.Add(v);
                }  
            }
        }
        step++;
    }
    return -1;
}
```

## BFS 的運行步驟詳解：

1. **初始化**：起始節點被加入佇列並標記為已訪問。

2. **第一輪遍歷**：
   - 取出當前佇列的第一個節點並處理它。
   - 將所有鄰接節點加入佇列並標記為已訪問。

3. **第二輪遍歷**：
   - 重複上述步驟，從佇列中取出新的節點並處理它，將鄰接節點加入佇列。

4. **結束遍歷**：
   - 當佇列空時，表示所有可以訪問的節點已被處理完畢。

## BFS 的應用：

1. **最短路徑問題（無權重圖）**：
   - BFS 用於無權重圖中尋找起點到終點的最短路徑。這是因為 BFS 每次都會優先遍歷離起點最近的節點，當第一次到達終點時，即已經是最短路徑。

2. **圖的遍歷**：
   - 用於遍歷圖中的所有節點，適用於搜索某個圖中所有可能的解決方案或模式。

3. **層次遍歷**：
   - BFS 可以幫助解決許多層次結構的問題，如公司組織結構、網絡拓撲等。

4. **序列化樹或圖**：
   - 使用 BFS，可以生成圖的層次序列化，便於對其進行儲存和恢復。

## BFS 的時間複雜度：
- **時間複雜度**：對於圖中的每個節點，我們將訪問它一次，並遍歷所有相鄰的邊一次。因此，時間複雜度為 **O(V + E)**，其中 V 是節點數，E 是邊數。
- **空間複雜度**：需要使用佇列來存儲節點，空間複雜度也是 **O(V)**，因為在最壞情況下，所有節點都可能進入佇列。

## BFS 與 DFS 的比較：
- **BFS** 使用 **佇列**，逐層遍歷圖，適合用於找最短路徑、層次遍歷等問題。
- **DFS** 使用 **遞迴** 或 **堆疊**，深度優先遍歷，適合解決連通分量、拓撲排序、迷宮尋路等問題。

## 優點與缺點：

### 優點：
- **簡單易理解**：BFS 直觀且簡單，容易實現。
- **最短路徑**：適合用來解決無權重圖中的最短路徑問題。
- **適用範圍廣泛**：可應用於多種不同類型的圖問題，如任務調度、編輯距離等。

### 缺點：
- **空間消耗大**：在某些情況下，BFS 需要大量的空間來存儲佇列中的節點，這可能會對內存產生較大壓力。
- **不適合帶權圖的最短路徑**：BFS 只適用於無權重的圖，對於帶權圖，使用 Dijkstra 或 Bellman-Ford 等算法會更合適。

## 結論：
BFS 是圖遍歷中一個基礎而強大的算法，能夠在無權圖中找到最短路徑，並能夠有效地解決層次結構的問題。它的簡單性和有效性使它成為許多圖算法中的核心技術之一。使用 BFS 時需要注意其空間複雜度，特別是在處理大規模圖時。

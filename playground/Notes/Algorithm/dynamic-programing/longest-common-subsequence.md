# 最長共同子序列 (Longest Common Subsequence, LCS)

## 1. 問題定義

給定兩個字串 $str1$ 和 $str2$，目標是找出它們之間**最長**的**共同子序列**的長度。

**子序列 (Subsequence)**：一個字串的子序列是從原字串中刪除零個或多個字元後，剩餘字元保持其原有相對順序所形成的序列。子序列不要求連續。

**範例**：
* $str1 = \text{"AGGTAB"}$
* $str2 = \text{"GXTXAYB"}$
* 它們的最長共同子序列是 "GTAB"，其長度為 4。 (其他共同子序列如 "GTB", "GAB", "ATB" 等，但它們的長度都小於 4)

## 2. 核心思想：動態規劃 (Dynamic Programming)

LCS 問題是一個典型的動態規劃問題，透過構建一個二維表來解決。

### 2.1. 動態規劃狀態定義

我們定義 $dp[i][j]$ 為 $str1$ 的前 $i$ 個字元（即 $str1[0 \dots i-1]$）和 $str2$ 的前 $j$ 個字元（即 $str2[0 \dots j-1]$）的最長共同子序列的長度。

* 在這裡，我們使用 1-based indexing 來定義 $dp$ 表格的 $i$ 和 $j$，這樣 $dp[i][j]$ 就對應到 $str1$ 的第 $i$ 個字元和 $str2$ 的第 $j$ 個字元。實際存取字串時，仍需使用 0-based indexing，即 $str1[i-1]$ 和 $str2[j-1]$。

### 2.2. 狀態轉移方程式 (Recurrence Relation)

$$
dp[i][j] = \begin{cases}
1 + dp[i-1][j-1] & \text{if } str1[i-1] = str2[j-1] \\
\max(dp[i-1][j], dp[i][j-1]) & \text{if } str1[i-1] \neq str2[j-1]
\end{cases}
$$

* **情況一：$str1[i-1]$ 和 $str2[j-1]$ 相等**
    * 如果當前比較的兩個字元相等，則它們可以構成共同子序列的一部分。此時，最長共同子序列的長度會比 $str1$ 的前 $i-1$ 個字元和 $str2$ 的前 $j-1$ 個字元的最長共同子序列長度多 1。

* **情況二：$str1[i-1]$ 和 $str2[j-1]$ 不相等**
    * 如果當前比較的兩個字元不相等，則我們必須捨棄其中一個字元。
    * 選擇 $str1$ 的前 $i-1$ 個字元與 $str2$ 的前 $j$ 個字元的 LCS 長度 ($dp[i-1][j]$)。
    * 選擇 $str1$ 的前 $i$ 個字元與 $str2$ 的前 $j-1$ 個字元的 LCS 長度 ($dp[i][j-1]$)。
    * 取這兩者中的最大值，因為我們需要找到最長的共同子序列。

### 2.3. 邊界條件 (Base Cases)

當其中一個字串為空時，它們的最長共同子序列長度為 0。
* $dp[0][j] = 0$ (當 $str1$ 的前 0 個字元，即空字串，與 $str2$ 的前 $j$ 個字元比較時)
* $dp[i][0] = 0$ (當 $str2$ 的前 0 個字元，即空字串，與 $str1$ 的前 $i$ 個字元比較時)

### 2.4. 計算順序 (Computation Order)

我們通常以**底部向上 (Bottom-Up)** 的方式填充 $dp$ 表格：
從 $i = 1$ 到 $str1.length$ 進行外部迴圈，
從 $j = 1$ 到 $str2.length$ 進行內部迴圈。
這樣可以確保在計算 $dp[i][j]$ 時，所有其依賴的子問題（如 $dp[i-1][j-1]$、$dp[i-1][j]$、$dp[i][j-1]$）都已經計算完成。

### 2.5. 最終結果 (Final Result)

經過上述計算，最終的結果會儲存在 $dp[str1.length][str2.length]$ 中，這就是兩個字串的最長共同子序列的長度。

---

**關於「維護最長的共同子序列列表」的澄清**：
$dp[i][j]$ 通常只儲存最長共同子序列的**長度**。如果需要**重建 (reconstruct)** 實際的子序列，則需要在動態規劃的過程中，另外記錄每個 $dp[i][j]$ 是由哪個前一個狀態轉移而來（例如，通過一個額外的 `path` 或 `choice` 表格），然後從 $dp[str1.length][str2.length]$ 回溯即可。

## 3. 時間與空間複雜度 (Time and Space Complexity)

* **時間複雜度：O(M * N)**
    * 其中 $M$ 是 $str1$ 的長度，$N$ 是 $str2$ 的長度。我們需要填充一個 $M \times N$ 的 $dp$ 表格，每個單元格的計算是常數時間。
* **空間複雜度：O(M * N)**
    * 用於儲存 $M \times N$ 的 $dp$ 表格。
    * **空間優化**：由於在計算 $dp[i][j]$ 時，只依賴於前一行 ($dp[i-1][\dots]$) 和當前行 ($dp[i][j-1]$) 的值，因此可以將空間複雜度優化到 $O(\min(M, N))$ 或 $O(N)$（只需儲存兩行 $dp$ 值或只儲存一行並原地更新）。

## 4. 應用與相關題目 (Applications and Related Problems)

* **LeetCode #1143: Longest Common Subsequence**：這是直接的 LCS 問題。
* **版本控制系統**：如 Git 的 `diff` 命令，用於比較兩個文件版本之間的差異，找出共同的部分和不同的部分，其核心演算法就是 LCS。
* **生物信息學**：用於比對 DNA 或蛋白質序列，找出它們之間的相似性或演化關係。
* **拼寫檢查與語音識別**：在計算字串相似度或糾錯時，LCS 可以作為一種度量標準。
* **資料壓縮**：在某些壓縮演算法中，找出重複模式或子序列以提高壓縮效率。
* **其他動態規劃問題**：LCS 是許多其他字串動態規劃問題的基礎，例如最長共同子字串 (Longest Common Substring)、最短共同父序列 (Shortest Common Supersequence) 等。
namespace playground.LeetCode._0000_0999;

public class _0928_MinMalwareSpread
{
    /// <summary>
    /// disjoint set: O(k * n^2), k = <paramref name="initial"/>.Count
    /// </summary>
    public static int MinMalwareSpread(int[][] graph, int[] initial)
    {
        int n = graph.Length;
        var ds = new DisjointSet(n);
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (graph[i][j] == 1)
                {
                    ds.Join(i, j);
                }
            }
        }

        var originalMal = new int[n];
        foreach (var u in initial)
        {
            int g = ds.Find(u);
            originalMal[g] = ds.rs[g];
        }
        int originalTotalMal = originalMal.Sum();

        int res = 0, cur = n;
        foreach (var u in initial)
        {
            var ds2 = new DisjointSet(n);
            for (int i = 0; i < n; i++)
            {
                if (i == u) continue;
                for (int j = i + 1; j < n; j++)
                {
                    if (j == u) continue;
                    if (graph[i][j] == 1)
                    {
                        ds2.Join(i, j);
                    }
                }
            }

            var mal = new int[n];
            foreach (var u2 in initial)
            {
                if (u == u2) continue;
                int g = ds2.Find(u2);
                mal[g] = ds2.rs[g];
            }
            int curMal = mal.Sum();
            if (curMal < cur || curMal == cur && u < res)
            {
                res = u;
                cur = curMal;
            }
        }
        return res;
    }

    /// <summary>
    /// bfs: O(k * n^2), k = <paramref name="initial"/>.Count
    /// </summary>
    public static int MinMalwareSpread2(int[][] graph, int[] initial)
    {
        int n = graph.Length;
        Array.Sort(initial);

        int bfs(int removed)
        {
            var q = new Queue<int>();
            var seen = new bool[n];
            seen[removed] = true;
            foreach (var node in initial)
            {
                if (node != removed)
                {
                    q.Enqueue(node);
                    seen[node] = true;
                }
            }
            int count = 0;
            while (q.Count > 0)
            {
                count++;
                var u = q.Dequeue();
                for (int i = 0; i < n; i++)
                {
                    if (!seen[i] && graph[u][i] == 1)
                    {
                        q.Enqueue(i);
                        seen[i] = true;
                    }
                }
            }
            return count;
        }

        int res = 0, minMal = n;
        foreach (var node in initial)
        {
            int cur = bfs(node);
            if (cur < minMal)
            {
                res = node;
                minMal = cur;
            }
        }
        return res;
    }
}
